#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "CNF_Form.h"

int backtrackToLevel;

Asignation new_Asignation(int variable, int value, int level,int desition)
{
  Asignation a=(Asignation)malloc(sizeof(struct asignation));
  a->variable=variable;
  a->value=value;
  a->level=level;
  a->desition=desition;

  return a;
}

AsignationTree new_AsignationTree()
{
  AsignationTree t=(AsignationTree)malloc(sizeof(struct asignationTree));
  List incident=(List)malloc(sizeof(struct list));
  List leaf=(List)malloc(sizeof(struct list));
  //t->root=root;
  t->incidents=incident;
  t->leaf=leaf;

  return t;
}

void AsignationTree_insert(AsignationTree t,Asignation in,TreeVertice dest)
{
  if(in->desition == TRUE)
  {
    TreeVertice In=(TreeVertice)malloc(sizeof(struct treeVertice));
    In->asig=in;
    In->incident=(List)malloc(sizeof(struct list));
    t->incidents = append(t->incidents,In);
    t->leaf = append(t->leaf,in);

    if(t->asigMaxLevel->level < in->level)
    {
        t->asigMaxLevel=in;
    }
  }
  
  dest->incident = append(dest->incident,in);
}

Asignation findMaxLevelAsignation(AsignationTree t)
{
    List it=init(t->leaf);
    Asignation max=(Asignation)yield(it);
    Asignation a;
    for(it = init(t->leaf); ended(it); next(it))
    {
        a=(Asignation)yield(it);
        if(max->level < a->level)
            max=a;
    }
    return max;
}

void AsignationTree_update(AsignationTree t)
{
    List it;
    Asignation asig=(Asignation)malloc(sizeof(struct asignation));
    asig->desition=FALSE;
    asig->level=t->asigMaxLevel->level;
    asig->value=t->asigMaxLevel->value*(-1);
    asig->variable=t->asigMaxLevel->variable;
    delete(t->leaf,t->asigMaxLevel);
    //buscar la hoja de mayor nivel en t->leaf y asignarla a t->asigMaxLevel
    t->asigMaxLevel=findMaxLevelAsignation(t);
    TreeVertice max=(TreeVertice)malloc(sizeof(struct treeVertice));
    max->asig=asig;
    max->incident=(List)malloc(sizeof(struct list));

    destroy(t->incidents);//borrar la lista de indidentes y sus contenidos
                        //mosca no debes destruir todo
    for (it = init(t->leaf); ended(it); it = next(it))
    {
        TreeVertice v=(TreeVertice)malloc(sizeof(struct treeVertice));
        v->asig=(Asignation)yield(it);
        v->incident=(List)malloc(sizeof(struct list));
        max->incident = append(max->incident,v->asig);
        t->incidents = append(t->incidents,v);
    }

    t->incidents = append(t->incidents,max);
}

void addLearnClause(CNF_Form f, List leafs) {
  List it;
  Asignation as;
  int lit;
  Clause cl = CNF_createClause(size(leafs));
  for (it = init(leafs); ended(it); it = next(it)) {
    as = (Asignation)yield(it);
    if (as->value == TRUE)
      lit = map(-(as->variable));
    else
      lit = map(as->variable);
    cl->literals = append(cl->literals,f->literals[lit]);
  }
  f->clauses = append(f->clauses,cl);
}

Clause CNF_createClause(int size) {
  Clause c = (Clause)malloc(sizeof(struct clause));
  c->numSat = 0;
  c->numNotSat = 0;
  c->isSatisf = UNASSIGNED;
  c->size = size;
  c->literals = newList();
  return c;
}

CNF_Form CNF_create(int numVar, int numCla) {
  CNF_Form f = (CNF_Form)malloc(sizeof(struct form));
  f->numLiterals = 2 * numVar;
  f->numVar = numVar;
  f->numClauses = numCla;
  f->literals = (Literal *)malloc(2*numVar*(sizeof(struct literal)));
  f->clauses = newList();
  f->satClauses = 0;
  f->numVarAssig = 0;
  f->assigUnitProp = newList();
  int i;
  Literal lit;
  for (i = 0; i < 2 * numVar; i++) {
    lit = (Literal)malloc(sizeof(struct literal));
    lit->value = UNASSIGNED;
    lit->clauses = newList();
    f->literals[i] = lit;
  }
  return f;
}

int CNF_addClause(CNF_Form f, int lit[], int size) {
  Clause c = CNF_createClause(size);
  int i;
  for (i = 0; i < size; i++) {
    c->literals = append(c->literals, (f->literals[map(lit[i])])); 
    (f->literals)[map(lit[i])]->clauses = append((f->literals)[map(lit[i])]->clauses, c);
  }
  f->clauses = append(f->clauses, c);
  return 1;
}


int map(int etiquetaLit) {
  if (etiquetaLit > 0) {
    return 2 * etiquetaLit - 2;
  } else if (etiquetaLit < 0) {
    return -2 * etiquetaLit - 1;
  } else {
    printf("Error: etiqueta de literal no valida.");
    return (EXIT_FAILURE);
  }
}

int getVar(int lit) {
  if (lit % 2 == 0)
    return (lit + 2) / 2;
  else 
    return -(lit + 2) / 2;
}

int CNF_DPLL(CNF_Form f, int level,AsignationTree t)
{

  backtrackToLevel = level;
  int lit;
  int numAssigUP = 0;


  int IsSolution=isSolution(f);

  if (IsSolution == TRUE)
  {
    return TRUE;

  } else if(IsSolution == FALSE){

      if(t->asigMaxLevel!=NULL)
        AsignationTree_update(t);

   // addLearnClause(f,t->leaf); hay que agregar la clausula evaluada

    backtrackToLevel = level-1;
    return FALSE;
  } 
  else
  {

    pureLiteralElim(f,level);

    lit = chooseLiteral(f);

    if (lit < 0)
    {
        backtrackToLevel = level-1;
      return FALSE;

    }
 
    assignLiteral(f,lit,TRUE,level,TRUE);

    unitPropagation(f,&numAssigUP,t,level);

    if (CNF_DPLL(f,level+1,t) == TRUE)

      return TRUE;

    else
    {

      restoreUnitProp(f,&numAssigUP);

      restoreState(f,lit,TRUE);

      if(level==backtrackToLevel)
      {
        assignLiteral(f,lit,FALSE,level,TRUE);

        unitPropagation(f,&numAssigUP,t,level);

        if (CNF_DPLL(f,level+1,t) == TRUE)
            return TRUE;

        else
        {
            restoreUnitProp(f,&numAssigUP);
            restoreState(f,lit,FALSE);
        }
      }
    }
    if(level==backtrackToLevel)
    {
        if(t->asigMaxLevel!=NULL)
            backtrackToLevel=t->asigMaxLevel->level;
        else
            backtrackToLevel=level-1;
    }
    return FALSE;
  }
}


int isSolution(CNF_Form f)
{
    List it;
    Clause cl;
  if (f->numVarAssig == f->numVar && f->satClauses == f->numClauses)
    return TRUE;
  for (it = init(f->clauses); ended(it); it = next(it))
  {
    cl = (Clause)yield(it);
    if (cl->isSatisf == FALSE)
      return FALSE;
  }
  if(f->numVarAssig != f->numVar)
      return UNASSIGNED;
}

int chooseLiteral(CNF_Form f) {
  int i = 0;
  for (i = 0; i < f->numLiterals; i++)
    if (f->literals[i]->value == UNASSIGNED) {
      return i;
    }
  return -1;
}

void assignLiteral(CNF_Form f, int lit, int value,int level, int desition) {
    Asignation a;
  int posLit1 = lit;
  int posLit2 = 0;
  if (lit % 2 == 0)
  {
    posLit2 = lit + 1;
    a=new_Asignation((lit+2)/2,value,level,desition);
  }
  else
  {
    posLit2 = lit - 1;
    a=new_Asignation((lit+2)/2,value*(-1),level,desition);
  }
  f->literals[posLit1]->value = value;
  f->literals[posLit1]->asig = a;
  f->literals[posLit2]->asig = a;
  if (value == TRUE)
    f->literals[posLit2]->value = FALSE;
  else
    f->literals[posLit2]->value = TRUE;
  updateClauses(f, posLit1, posLit2);
  f->numVarAssig++;
}

void updateClauses(CNF_Form f, int posLit1, int posLit2) {
  List it;
  Clause cl;
  Literal lit = f->literals[posLit1];
  for (it = init(lit->clauses); ended(it); it = next(it)) {
    cl = ((Clause)yield(it));
    if (cl->isSatisf == TRUE && lit->value == TRUE)
      cl->numSat++;
    else {
      if (lit->value == TRUE) {
        cl->numSat++;
        cl->isSatisf = TRUE;
        f->satClauses++;
      } else {
        cl->numNotSat++;
        if(cl->size == cl->numNotSat)
            cl->isSatisf=FALSE;

      }
    }
  }
  lit = f->literals[posLit2];
  for (it = init(lit->clauses); ended(it); it = next(it)) {
    cl = ((Clause)yield(it));
    if (cl->isSatisf == TRUE && lit->value == TRUE)
      cl->numSat++;
    else {
      if (lit->value == TRUE) {
        cl->numSat++;
        cl->isSatisf = TRUE;
        f->satClauses++;
      } else {
        cl->numNotSat++;
        if(cl->size == cl->numNotSat)
            cl->isSatisf=FALSE;
      }
    }
  }
}

void restoreState(CNF_Form f, int lit, int value) {
  int posLit1 = lit;
  int posLit2 = 0;
  if (lit % 2 == 0)
    posLit2 = lit + 1;
  else
    posLit2 = lit - 1;
  restoreClauses(f, posLit1, posLit2);
  f->literals[posLit1]->value = UNASSIGNED;
  free(f->literals[posLit1]->asig);
  f->literals[posLit1]->asig=NULL;
  f->literals[posLit2]->value = UNASSIGNED;
  f->literals[posLit2]->asig=NULL;
  f->numVarAssig--;
}

void restoreClauses(CNF_Form f, int posLit1, int posLit2) {
  List it;
  Clause cl;
  Literal lit = f->literals[posLit1];
  for (it = init(lit->clauses); ended(it); it = next(it)) {
    cl = ((Clause)yield(it));
    if (lit->value == TRUE) {
      cl->numSat--;
      if (cl->numSat == 0) {
        cl->isSatisf = UNASSIGNED;
        f->satClauses--;
      }
    } else {
      cl->numNotSat--;
      if(cl->numSat==0)
          cl->isSatisf=UNASSIGNED;
    }
  }
  lit = f->literals[posLit2];
  for (it = init(lit->clauses); ended(it); it = next(it)) {
    cl = ((Clause)yield(it));
    if (lit->value == TRUE) {
      cl->numSat--;
      if (cl->numSat == 0) {
        cl->isSatisf = UNASSIGNED;
        f->satClauses--;
      }
    } else {
      cl->numNotSat--;
      if(cl->numSat==0)
        cl->isSatisf = UNASSIGNED;
    }
  }
}

void insertImplicationsForAClause(AsignationTree t,Clause clau,TreeVertice A)
{
    List it;
    Literal lit;

    for(it=init(clau->literals); ended(it); it=next(it))
    {
        lit=(Literal)yield(it);
        AsignationTree_insert(t,lit->asig,A);
    }
}

void unitPropagation(CNF_Form f, int *numAssigUP,AsignationTree t,int level) {
  List it;
  Clause cl;
  Literal unitLit;
  int lit;
  int continues=1;

  while(continues)
  {
      continues=0;
    for (it = init(f->clauses); ended(it); it = next(it))
    {
    
        cl = (Clause)yield(it);
    
        if (cl->isSatisf == FALSE && isUnit(cl) == TRUE)
        {
         getUnitLiteral(cl);
      
         if (cl->unitLit != NULL)
         {
       
            unitLit = cl->unitLit;
               
            lit = searchLitPos(f->literals, unitLit, f->numLiterals);
        
            f->assigUnitProp = append(f->assigUnitProp,unitLit);
            (*numAssigUP)++;
             assignLiteral(f,lit,TRUE,level,FALSE);

            TreeVertice A=(TreeVertice)malloc(sizeof(struct treeVertice));
            A->asig=f->literals[lit]->asig;
            A->incident=(List)malloc(sizeof(struct list));

            t->incidents = append(t->incidents,A);

            insertImplicationsForAClause(t, cl, A);
            continues=1;
          }
       }
    }
  }
}

void restoreUnitProp(CNF_Form f, int *numAssigUP) {
  List it;
  Literal lit;
  int posL;
  List litToDel = newList();

  if (*numAssigUP == 0)
    return;

  for (it = init(f->assigUnitProp); ended(it); it = next(it)) {

    if (*numAssigUP == 0)
      break;

    lit = (Literal)yield(it);
    posL = searchLitPos(f->literals, lit, f->numLiterals);

    restoreState(f,posL,TRUE);

    litToDel = append(litToDel,lit);
    (*numAssigUP)--;

  }

  for (it = init(litToDel); ended(it); it = next(it)) {
    lit = (Literal)yield(it);
    delete(f->assigUnitProp,lit);
  }

  freeList(litToDel);

}

int isUnit(Clause cl) {
  if (cl->isSatisf == FALSE && cl->numNotSat == (cl->size -1))
    return TRUE;
  else return FALSE;
}

void getUnitLiteral(Clause cl) {
  List it;
  Literal lit;
  for (it = init(cl->literals); ended(it); it = next(it)) {
    lit = (Literal)yield(it);
    if (lit->value == UNASSIGNED)
      cl->unitLit = lit;
  }
}

int searchLitPos(Literal *literals, Literal l, int tam) {
  int i = 0;
  for (i = 0; i < tam; i++) {
    if (literals[i] == l)
      return i;
  }
  return -1;
}

void pureLiteralElim(CNF_Form f,int level) {
  int i = 0;
  for (i = 0; i < f->numLiterals; i++) {
    if (size(f->literals[i]->clauses) == 0) {
      if (f->literals[i]->value == UNASSIGNED)
        assignLiteral(f,i,FALSE,level,FALSE);
    }
  }
}
