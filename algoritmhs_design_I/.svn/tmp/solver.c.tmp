/* 
 * File:   solver.c
 * Desc: Programa principal de la ejecucion del solver
 * Author: Juan J Garcia
 *         Federico Flaviani
 * Created on February 25, 2011, 6:55 AM
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "CNF_Form.h"

void getValue(int *solution, int *sol, int n) {
  int i = 0;
  for (i = 0; i < n*n; i++) {
    sol[i] = 1 + ((solution[i] - 1) % n);
  }
}

// Funcion que procesa el archivo CNF y llama las corre el Solver
int procesarArchivo(FILE* archivo) {
  CNF_Form f;
  char line[256];
  int literals[128], numVar, numClauses, i, solution[numVar], var, solSudoku[81];
  int itsSolution = FALSE;
  double start, end, timeExec;


  // Se lee el archivo y se crean las clausulas
  while (fgets(line, sizeof line, archivo) != NULL) {
    
    // Caso en que se ignora un comentario
    if (line[0] == 'c' || line[0] == '\n') {
      continue;
    }

    // Caso en que se encuentra la linea del problema
    if (line[0] == 'p') {
      strtok(line, " ");
      strtok(NULL, " "); 
      numVar = atoi(strtok(NULL, " "));
      numClauses = atoi(strtok(NULL, " "));
      printf("\nNumero de Variables = %d \n", numVar);
      printf("Numero de Clausulas =  %d\n", numClauses);

      // Se crea la formula CNF para representar el problema
      f = CNF_create(numVar, numClauses);
      continue;
    }
    i = 0;
    literals[i] = atoi(strtok(line, " "));
    for (i = 1; literals[i] = atoi(strtok(NULL, " ")); i++) { }

    // Se agrega la clausula a la formula
    CNF_addClause(f, literals, i);

  }
     
  start = time(NULL);

  // Se crea un nuevo arbol de asignaciones
  AsignationTree t = new_AsignationTree();

  // Se corre el DPLL para encontrar la solucion al problema
  itsSolution = CNF_DPLL(f,1,t);

  end = time(NULL);
  timeExec = end - start;

  // Caso en que existe solucion
  if (itsSolution == TRUE) {

    printf("SAT = ");
    for (i = 0; i < f->numLiterals; i++) {
      var = getVar(i);
      if (f->literals[i]->value == TRUE)
        solution[i/2] = var;
      else solution[i/2] = -var;
    }
    for (i = 0; i < f->numVar; i++) {
      if (solution[i] > 0) 
        printf("%d ",solution[i]);
    }

    getValue(solution, solSudoku, 9);
    printf("\nVar Assig = %d\n",f->numVarAssig);    
    printf("Tiempo de ejecucion = %f\n",timeExec);
    printf("Solucion Sudoku = ");
    for (i = 0; i < 81; i++)
      printf("%d",solSudoku[i]);
    printf("\n");
    // Caso en que no existe una solucion
  } else {

    printf("UNSAT = ");
    for (i = 0; i < f->numLiterals; i++) {
      var = getVar(i);
      if (f->literals[i]->value == TRUE)
        solution[i/2] = 0;
      else solution[i/2] = 0;
    }
    for (i = 0; i < f->numVar; i++) {
      if (solution > 0) 
        printf("%d ",solution[i]);
    }
    printf("\nVar Assig = %d\n",f->numVarAssig);    
    printf("Tiempo de ejecucion = %f\n",timeExec);    
  }

  printf("Finalizado.\n");
}

// Programa Principal
main(int argc, char** argv) {
  FILE* archivo;
    
  if (argc != 2) {
    printf("%s\n", "Error: do ./solver <inputFile>");
    return (EXIT_FAILURE);
  }
    
<<<<<<< .mine
  if ((archivo = fopen(argv[1], "r")) != NULL) {
=======
  if ((archivo = fopen(/*argv[1]*/"data", "r")) != NULL) {
>>>>>>> .r31
    procesarArchivo(archivo);
    fclose(archivo);
    return (EXIT_SUCCESS);
  } else {
    printf("%s\n", "Problema al abrir el archivo.");
    printf("%s\n", "Se abortara la ejecucion.");
    return (EXIT_FAILURE);
  }
  return (EXIT_SUCCESS);
}

