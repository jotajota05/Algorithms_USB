#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "CNF_Form.h"

Asignation new_Asignation(int variable, int value, int level)
{
  Asignation a=(Asignation)malloc(sizeof(struct asignation));
  a->variable=variable;
  a->value=value;
  a->level=level;

  return a;
}

AsignationTree new_AsignationTree()
{
  AsignationTree t=(AsignationTree)malloc(sizeof(struct asignationTree));
  List incident=(List)malloc(sizeof(struct list));
  List leaf=(List)malloc(sizeof(struct list));
  //t->root=root;
  t->incidents=incident;
  t->leaf=leaf;

  return t;
}

void AsignationTree_insert(AsignationTree t,Asignation in,Asignation dest)
{
  TreeVertice In=(TreeVertice)malloc(sizeof(struct treeVertice));
  In->asig=in;
  In->incident=(List)malloc(sizeof(struct list));
  append(t->incidents,In);//se supone que todas las asignaciones
  //que se insertan son distintas
  append(t->leaf,in);

  if(dest!=NULL)
    {
      append(((TreeVertice)find(t->incidents,dest))->incident,in);

      delete(t->leaf,dest);//supongo que delete no surte efecto si dest no
      //esta en la lista
    }
}

void AsignationTree_update(AsignationTree t)
{
    List it;
    Asignation asig;
    delete(t->leaf,t->asigMaxLevel);
    TreeVertice max=(TreeVertice)malloc(sizeof(struct treeVertice));
    max->asig=t->asigMaxLevel;
    max->incident=(List)malloc(sizeof(struct list));
    destroy(t->incidents);
    for (it = init(t->leaf); ended(it); it = next(it))
    {
        TreeVertice v=(TreeVertice)malloc(sizeof(struct treeVertice));
        v->asig=(Asignation)yield(it);
        v->incident=(List)malloc(sizeof(struct list));
        append(max->incident,v->asig);
        append(t->incidents,v);
    }
    append(t->incidents,max);
}

Clause CNF_createClause(int size) {
  Clause c = (Clause)malloc(sizeof(struct clause));
  c->numSat = 0;
  c->numNotSat = 0;
  c->isSatisf = FALSE;
  c->size = size;
  c->literals = newList();
  return c;
}

CNF_Form CNF_create(int numVar, int numCla) {
  CNF_Form f = (CNF_Form)malloc(sizeof(struct form));
  f->numLiterals = 2 * numVar;
  f->numVar = numVar;
  f->numClauses = numCla;
  f->literals = (Literal *)malloc(2*numVar*(sizeof(struct literal)));
  f->clauses = newList();
  f->satClauses = 0;
  f->numVarAssig = 0;
  f->assigUnitProp = newList();
  int i;
  Literal lit;
  for (i = 0; i < 2 * numVar; i++) {
    lit = (Literal)malloc(sizeof(struct literal));
    lit->value = UNASSIGNED;
    lit->clauses = newList();
    f->literals[i] = lit;
  }
  return f;
}

int CNF_addClause(CNF_Form f, int lit[], int size) {
  Clause c = CNF_createClause(size);
  int i;
  for (i = 0; i < size; i++) {
    c->literals = append(c->literals, (f->literals[map(lit[i])])); 
    (f->literals)[map(lit[i])]->clauses = append((f->literals)[map(lit[i])]->clauses, c);
  }
  f->clauses = append(f->clauses, c);
  return 1;
}


int map(int etiquetaLit) {
  if (etiquetaLit > 0) {
    return 2 * etiquetaLit - 2;
  } else if (etiquetaLit < 0) {
    return -2 * etiquetaLit - 1;
  } else {
    printf("Error: etiqueta de literal no valida.");
    return (EXIT_FAILURE);
  }
}

int getVar(int lit) {
  if (lit % 2 == 0)
    return (lit + 2) / 2;
  else 
    return -(lit + 2) / 2;
}

int CNF_DPLL(CNF_Form f) {
  //int CNF_DPLL(CNF_Form f,int level, AsignationTree t) {

  int i = 0;
  int lit;
  //int noUnitLit=0;
  int numAssigUP = 0;

  //  pureLiteralElim(f);
  // Asignation a;
  int IsSolution=isSolution(f);

  if (IsSolution == TRUE) {
    return TRUE;

    //  } else if(IsSolution == FALSE){
  
    //      AsignationTree_update(t);
    //agregar clausula de aprendizaje
    //      return FALSE;
    //  }else{
    //    lit = unitPropagation(f);
  } else {

    pureLiteralElim(f);

    lit = chooseLiteral(f);

    if (lit < 0) {

      //      lit = chooseLiteral(f);
      //          level++;
      //          noUnitLit=1;
      //          a=new_Asignation((lit+2)/2,getVar(lit)*TRUE,level,NULL);

      return FALSE;

    }
    //   else
    //   {
    //       a=new_Asignation((lit+2)/2,getVar(lit)*TRUE,level,NULL);
    //       AsignationTree_insert(t,a,a);
    //   }

    assignLiteral(f,lit,TRUE);

    // append(asignations,a);
    // if (CNF_DPLL(f,level,t) == TRUE)

    unitPropagation(f,&numAssigUP);    

    if (CNF_DPLL(f) == TRUE)

      return TRUE;

    else {
      //      deleteEnd(asignations);

      restoreUnitProp(f,&numAssigUP);

      restoreState(f,lit,TRUE);

      //     if(noUnitLit)
      //    {
      //      assignLiteral(f,lit,FALSE);
      //      append(asignations,a);
      //      if (CNF_DPLL(f,level,t) == TRUE)
      //          return TRUE;
      //      else {
      //         deleteEnd(asignations);
      //         restoreState(f,lit,FALSE);
      //         return FALSE;
      //     }

      assignLiteral(f,lit,FALSE);
      unitPropagation(f,&numAssigUP);    

      if (CNF_DPLL(f) == TRUE)
        return TRUE;

      else {

        restoreUnitProp(f,&numAssigUP);
        restoreState(f,lit,FALSE);
        
      }
    }
    return FALSE;
  }
}


int isSolution(CNF_Form f) {
  if (f->numVarAssig == f->numVar && f->satClauses == f->numClauses)
    return TRUE;
  return FALSE;
}

int chooseLiteral(CNF_Form f) {
  int i = 0;
  for (i = 0; i < f->numLiterals; i++)
    if (f->literals[i]->value == UNASSIGNED) {
      return i;
    }
  return -1;
}

void assignLiteral(CNF_Form f, int lit, int value) {
  int posLit1 = lit;
  int posLit2 = 0;
  if (lit % 2 == 0)
    posLit2 = lit + 1;
  else
    posLit2 = lit - 1;
  f->literals[posLit1]->value = value;
  if (value == TRUE)
    f->literals[posLit2]->value = FALSE;
  else
    f->literals[posLit2]->value = TRUE;
  updateClauses(f, posLit1, posLit2);
  f->numVarAssig++;
}

void updateClauses(CNF_Form f, int posLit1, int posLit2) {
  List it;
  Clause cl;
  Literal lit = f->literals[posLit1];
  for (it = init(lit->clauses); ended(it); it = next(it)) {
    cl = ((Clause)yield(it));
    if (cl->isSatisf == TRUE && lit->value == TRUE)
      cl->numSat++;
    else {
      if (lit->value == TRUE) {
        cl->numSat++;
        cl->isSatisf = TRUE;
        f->satClauses++;
      } else {
        cl->numNotSat++;
      }
    }
  }
  lit = f->literals[posLit2];
  for (it = init(lit->clauses); ended(it); it = next(it)) {
    cl = ((Clause)yield(it));
    if (cl->isSatisf == TRUE && lit->value == TRUE)
      cl->numSat++;
    else {
      if (lit->value == TRUE) {
        cl->numSat++;
        cl->isSatisf = TRUE;
        f->satClauses++;
      } else {
        cl->numNotSat++;
      }
    }
  }
}

void restoreState(CNF_Form f, int lit, int value) {
  int posLit1 = lit;
  int posLit2 = 0;
  if (lit % 2 == 0)
    posLit2 = lit + 1;
  else
    posLit2 = lit - 1;
  restoreClauses(f, posLit1, posLit2);
  f->literals[posLit1]->value = UNASSIGNED;
  f->literals[posLit2]->value = UNASSIGNED;
  f->numVarAssig--;
}

void restoreClauses(CNF_Form f, int posLit1, int posLit2) {
  List it;
  Clause cl;
  Literal lit = f->literals[posLit1];
  for (it = init(lit->clauses); ended(it); it = next(it)) {
    cl = ((Clause)yield(it));
    if (lit->value == TRUE) {
      cl->numSat--;
      if (cl->numSat == 0) {
        cl->isSatisf = FALSE;
        f->satClauses--;
      }
    } else {
      cl->numNotSat--;
    }
  }
  lit = f->literals[posLit2];
  for (it = init(lit->clauses); ended(it); it = next(it)) {
    cl = ((Clause)yield(it));
    if (lit->value == TRUE) {
      cl->numSat--;
      if (cl->numSat == 0) {
        cl->isSatisf = FALSE;
        f->satClauses--;
      }
    } else {
      cl->numNotSat--;
    }
  }
}

void unitPropagation(CNF_Form f, int *numAssigUP) {
  List it;
  Clause cl;
  Literal unitLit;
  int lit;

  for (it = init(f->clauses); ended(it); it = next(it)) {
    
    cl = (Clause)yield(it);
    
    if (cl->isSatisf == FALSE && isUnit(cl) == TRUE) {

      getUnitLiteral(cl);
      
      if (cl->unitLit != NULL) {
       
        unitLit = cl->unitLit;
               
        lit = searchLitPos(f->literals, unitLit, f->numLiterals);
        
        f->assigUnitProp = append(f->assigUnitProp,unitLit);
        (*numAssigUP)++;
        assignLiteral(f,lit,TRUE);
      }
    }
  }
}

void restoreUnitProp(CNF_Form f, int *numAssigUP) {
  List it;
  Literal lit;
  int posL;
  List litToDel = newList();

  if (*numAssigUP == 0)
    return;

  for (it = init(f->assigUnitProp); ended(it); it = next(it)) {

    if (*numAssigUP == 0)
      break;

    lit = (Literal)yield(it);
    posL = searchLitPos(f->literals, lit, f->numLiterals);

    restoreState(f,posL,TRUE);

    litToDel = append(litToDel,lit);
    (*numAssigUP)--;

  }

  for (it = init(litToDel); ended(it); it = next(it)) {
    lit = (Literal)yield(it);
    delete(f->assigUnitProp,lit);
  }

  /* free(litToDel->tail); */
  /* free(litToDel); */
  freeList(litToDel);

}

int isUnit(Clause cl) {
  if (cl->isSatisf == FALSE && cl->numNotSat == (cl->size -1))
    return TRUE;
  else return FALSE;
}

void getUnitLiteral(Clause cl) {
  List it;
  Literal lit;
  for (it = init(cl->literals); ended(it); it = next(it)) {
    lit = (Literal)yield(it);
    if (lit->value == UNASSIGNED)
      cl->unitLit = lit;
  }
}

int searchLitPos(Literal *literals, Literal l, int tam) {
  int i = 0;
  for (i = 0; i < tam; i++) {
    if (literals[i] == l)
      return i;
  }
  return -1;
}

void pureLiteralElim(CNF_Form f) {
  int i = 0;
  for (i = 0; i < f->numLiterals; i++) {
    if (size(f->literals[i]->clauses) == 0) {
      if (f->literals[i]->value == UNASSIGNED)
        assignLiteral(f,i,FALSE);
    }
  }
}
