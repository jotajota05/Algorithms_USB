/*
  Proyecto Diseno de Algoritmo II - CSP con Busqueda Local

  Juan Garcia 05-38207
  Federico Flaviani

  Compilar con: 
  Correr con: 
*/

#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <list>
#include "Piece.h"
#include "Pattern.h"

using namespace std;

Pattern * init_pattern(list<Piece *> pieces, int W, int H, int paper[10][83]) {
  Pattern * p = new Pattern(pieces, W, H); 
  int i, j, k, l;
  int min_large = 1000000;
  int min_level = 0;
  int count = 0;
  list<Piece *>::iterator it;
  Piece * actual_p;
  bool locate = false;
  bool final = false;
  int reset;;

  for (i = 0 ; i < W ; i++)
    for (j = 0 ; j < H ; j++)
      paper[i][j] = 0;

  for (it = pieces.begin() ; it != pieces.end() ; it++) {
    
    //sleep(1);
    count++;
    locate = false;
    final = false;
    actual_p = *it;
    //cout << "\nPieza = " << count << "\n\n";

    for (i = 0 ; i < W ; i++) {

      for (j = min_level ; j < min_level + (*actual_p).large ; j++) {

        //cout << i << "," << j << "\n";

        if (paper[i][j] == 0) {

          paper[i][j] = count;

          if (j == min_level) {

            if (min_large > min_level + (*actual_p).large) 
              reset = min_large;
            min_large = min_level + (*actual_p).large;
            
            cout << "Min_level 1= " << min_level << "\n";
            cout << "Min_large 1= " << min_large << "\n";
            cout << "Reset 1= " << reset << "\n";
      
            (*actual_p).pos[0][0] = i;
            (*actual_p).pos[0][1] = i + 1;
            (*actual_p).pos[1][0] = min_level;
            (*actual_p).pos[1][1] = min_level + (*actual_p).large;
            locate = true;

            //cout << "i = " << i << "\n";

          }

        } else break;

      }

      if (i == W - 1) final = true;
      if (locate == true) break;
      else 
        if (final == true) {
          if (min_large <= reset)  min_level = min_large;
          else {
            min_level = reset;
            reset = min_large;
          }

          i = 0;
          final = false;
        } else {
          //cout << "Heme aqui\n";
        }
    }

    if (final == true) {
      // cout << "Min_level 2= " << min_level << "\n";
      // cout << "Min_large 2= " << min_large << "\n";
      // cout << "Reset 2= " << reset << "\n";

      if (min_large <= reset)  min_level = min_large;
      else {
        min_level = reset;
        reset = min_large;
      }
    }

    // Ciclo para la impresion de la tela
    cout << "\n";
    for (k = 0 ; k < W ; k++) {
      for (l = 0 ; l < H ; l++) {
        if (paper[k][l] < 10 && paper[k][l] > 0) cout << "0" << paper[k][l] << " ";
        else {
          if (paper[k][l] != 0 ) cout << paper[k][l] << " ";
          else cout << "--";
        }
      }
      cout << "\n";
    }
    cout << "\n";

  }

  (*p).lines = min_large;
  return p;
}

list<Pattern> gen_vicinity(Pattern p) {
  list<Pattern> lp;
  return lp;
}

bool comparePieces(Piece * p1, Piece * p2) {
  if ((*p1).large > (*p2).large)
    return true;
  return false;
}

Pattern localSearch() {

  // int  k = 0;
  // list<Pattern> vicinity;
  // list<Pattern>::iterator it_v;
  // Pattern actual, next;

  // actual = init_pattern();

  // while ( k < 100) {
    
  //   vicinity = gen_vicinity(actual);

  //   for ( it_v = vicinity.begin() ; it_v != vicinity.end() ; it_v++ ) {

  //     if ( (*it_v).quality() < actual.quality() ) {

  //     }
  //   }

  //   actual = next;
  //   k++;
  // }
  
  // return actual;

}

Pattern ILS()
{
    // Pattern s_mejor=new Pattern();
    // Pattern s=localSearch(s_mejor);
    // s=s_mejor;
    // while(!criterioDeParada())
    // {
    //     Pattern s1=perturbar(s);
    //     s1=localSearch(s1);
    //     s=criterioAceptacion(s1,s);
    //     actualizar(s,s_mejor);
    // }
}


// Pattern perturbar(Pattern s)
// {
//     return NULL;
// }


void actualizar(Pattern s, Pattern s1)
{
    
}

int calcHeight(int *pieces, int n, int* heights) {

  int i = 0;
  int height = 0;
  for (i = 0; i < n; i++)
    height += pieces[i]*heights[i];

  return height;
}

int main (int argc, char **argv) {

  int i, j;
  int width = 10;
  int numPieces[] = {7, 14, 5, 5};
  int totalPieces = 31;
  int heightsP[] = {5, 2, 3, 1};
  int height = calcHeight(numPieces, 4, heightsP);
  cout << "Height = " << height << "\n";
  int paper[10][83];
  list<Piece *> pieces;
  int posP[2][2];
  Piece *P;
  Pattern * pat;

  for (i = 0; i < 4; i++) {
    for (j = 0; j < numPieces[i]; j++) {
      P = new Piece(heightsP[i],posP);
      pieces.push_back(P);
    }
  }

  pieces.sort(comparePieces);

  list<Piece *>::iterator it;
  // for (it = pieces.begin(); it != pieces.end(); it ++)
  //   cout << (**it).large << "\n";

  for (i = 0 ; i < 10 ; i++)
    for (j = 0 ; j < 55 ; j++)
      paper[i][j] = 0;


  pat = init_pattern(pieces,width,height,paper);

  cout << "Lineas = " << (*pat).lines++ << "\n";

  // for (i = 0 ; i < 10 ; i++) {
  //   for (j = 0 ; j < 60 ; j++) {
  //     if (paper[i][j] < 10 && paper[i][j] > 0) cout << "0" << paper[i][j] << " ";
  //     else {
  //       if (paper[i][j] != 0 ) cout << paper[i][j] << " ";
  //       else cout << "--";
  //     }
  //   }
  //   cout << "\n";
  // }

  return 0;
}
